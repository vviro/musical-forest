package de.lmu.dbs.musicalforest.classifier;

import java.util.List;

import de.lmu.dbs.jforest.core.*;
import de.lmu.dbs.jforest.core2d.RandomTree2d;
import de.lmu.dbs.jforest.sampler.Sampler;
import de.lmu.dbs.jforest.util.Logfile;

/**
 * Random tree implementation for f0 detection on 2-dimensional data (FFT/CQT spectrum etc.).
 * 
 * @author Thomas Weber
 *
 */
public class OnOffMusicalRandomTree extends RandomTree2d {

	/**
	 * Number of overtones generated by the Harmonics class
	 */
	public static final int NUM_OF_OVERTONES = 20;
	
	/**
	 * Number of classes. Class semantics: 0: Silence, 1: Note on, 2: Note off. 
	 */
	public static final int NUM_OF_CLASSES = 3;
	
	/**
	 * 
	 * @param params
	 * @param num
	 * @param log
	 * @throws Exception
	 */
	public OnOffMusicalRandomTree(ForestParameters params, int num, Logfile log) throws Exception {
		super(params, NUM_OF_CLASSES, num, log);
	}

	/**
	 * Creates a tree instance for recursion into a new thread. The arguments are just used to transport
	 * the arguments of growRec to the new thread. See method growRec source code.
	 * 
	 * @throws Exception 
	 * 
	 */
	public OnOffMusicalRandomTree(ForestParameters params, RandomTree root, Sampler<Dataset> sampler, List<Classification> classification, long count, Node node, int mode, int depth, int maxDepth) throws Exception {
		super(root, sampler, classification, count, node, mode, depth, maxDepth);
	}

	/**
	 * Creates a blank tree, used as a factory.
	 * 
	 * @throws Exception
	 */
	public OnOffMusicalRandomTree() throws Exception {
		super();
	}

	/**
	 * Provides the possibility to add tree specific log output per node.
	 * 
	 * @param pre
	 * @param countClassesLeft
	 * @param countClassesRight
	 * @param winner
	 * @param winnerThreshold
	 * @throws Exception
	 *
	@Override
	public void logAdditional(String pre, long[][][] countClassesLeft, long[][][] countClassesRight, int winner, int winnerThreshold) throws Exception {
		long silenceLeftW = countClassesLeft[winner][winnerThreshold][1]; 
		long noteLeftW = countClassesLeft[winner][winnerThreshold][0];
		long silenceRightW = countClassesRight[winner][winnerThreshold][1]; 
		long noteRightW = countClassesRight[winner][winnerThreshold][0];
		log.write(pre + "Left note: " + noteLeftW + ", silence: " + silenceLeftW + ", sum: " + (silenceLeftW+noteLeftW));
		log.write(pre + "Right note: " + noteRightW + ", silence: " + silenceRightW + ", sum: " + (silenceRightW+noteRightW));
	}
	//*/
}
